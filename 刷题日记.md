2022-12-5

[ #83 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

这题总的来说有三种解法：

1. 递归（相邻节点值相同，就更新指针）
2. 迭代（相邻节点值相同，就更新指针）
3. 迭代（向后寻找第一个与当前节点值不同的节点，并更新指针）

总的来说，这 3 种解法从上到下所需思考量依次升高、时空复杂度依次降低。而我一开始AC的代码是第三种，要是竞赛的话还是用第一种吧。



[ #589 N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)

1. 递归
2. 显示栈

递归当然是最好写的，模仿二叉树的写法就可以了；显示栈法则是模拟递归的过程，写起来稍显复杂，需要倒序遍历子节点入栈。

p.s：刚刚试了一下用队列的方法，果然还是不行呀！！递归就是栈的「后进先出」特点，是不能用队列的「先进先出」代替的！！

p.p.s：不知道能不能用「Morris法」呀，对于目前的学习目标没有打算深入研究，毕竟空间优化是次之的。



[ #496 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

1. ①哈希表存储 `num2` 的值到索引的映射，②双层循环遍历求出每个 `num1` 中的元素的下一个更大元素。虽然时间上较纯双层遍历更优，仍有优化余地。
2. 看到「单调栈」的标签后，尝试实现了：①哈希表存储 `num2` 的「值 → 索引」的映射，②额外开辟数组，存储 `num2` 中每个元素的下一个更大元素（利用单调栈实现线性时间）③遍历求出每个 `num1` 中的元素的下一个更大元素。

​	   这里可以看到「元素值 → 索引 →下一个更大元素」的求解过程中，「索引」这一步是多余的，我之所以建哈希表可能是受第一个方法实现的思维惯性影响。

3. ①哈希表存储 `num2` 的「值 → 下一个更大元素的映射」的映射，②遍历求出每个 `num1` 中的元素的下一个更大元素。

看来自己对单调队列/栈的运用和练习还不够，以后有空可以加强一下。



[ #1232 缀点成线](https://leetcode.cn/problems/check-if-it-is-a-straight-line/)

1. 斜率法（比较繁琐且低效，需要考虑除数为 0 的特殊情况、除法需要转浮点数处理，除法本身较乘法就是低效的）
2. 斜率法转乘法

也是受教了，以后除法不要忘了考虑除数为 0 的情况，另外能用乘法就不要用除法、一些题目如果对元素值进行乘法预处理不影响结果的话就果断用上。



[ #132 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

这题一开始我应该想到了 DP 法：定义 `dp[i]` 表示以索引 `i` 结尾的子字符串的最小分割数， `dp[i]` 的求解需要 2 层循环，每个子字符串的回文判定又需要一层循环，总体时间复杂度达到 $O(n^3)$ ，于是就放弃了 DP 的思路，开启了乱七八糟写代码模式、吭哧吭哧 2 个小时调试来调试去的最后还是选择放弃乖乖看题解。

关键点在于：先预处理出每个子字符串的回文情况 `isPalindrome[l][r]` 。



[ #1687 从仓库到码头运输箱子](https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/)

听说这是一道力扣题库 Rank20 的神题，自己也是光看题解、cv代码就花费 2 个小时。

牵涉到的知识点有：前缀和、dp、单调队列。

另外这里的 dp 求解时的枚举对象我也是没想到的，她枚举的是「上一次运送的最后一个箱子」，而我呢、想的是怎么保存 `dp[i]` 的最后一次运送状态（箱子数和箱子总重）、看元素 `i` 能不能加入 `dp[i-1]`的最后一次运送中，这个思路是行不通的、按照经验枚举 `i` 前面的索引 `j` 即可。



2022-12-6

[ #1588 所有奇数长度子数组的和](https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/)

第二次做了，AC很容易（由于数据量很小，n^3^ 或者 n^2^ 解法就可以通过），时隔一个月不到、还是记起了可以通过「贡献法」达到线性时间复杂度，即遍历数组、求解每个元素在奇数长度子数组中出现的次数。

但我还是花了40多分钟才AC，究其原因是没有明确好当前元素 `arr[i]` 、左侧元素 `arr[0...i-1]` 、右侧元素 `arr[i+1...n-1]` 元素是否一定要选、选几个的限制条件。我总是事后才明白很多东西，因为是「贡献法」，所以当前元素 `arr[i]` 必选，则左侧元素与右侧元素的选择方法数之和必为偶数（奇数+奇数 or 偶数+偶数），贡献次数为 = 左侧元素以 `arr[i-1]` 结尾的奇数子数组个数 * 右侧元素以 `arr[i+1]` 开头的奇数子数组个数 + 左侧元素以 `arr[i-1]` 结尾的偶数子数组个数（包括空子数组） * 右侧元素以 `arr[i+1]` 开头的偶数子数组个数（包括空子数组），记为：$ans=\sum_{i=0}^{n-1} arr[i]*(oddL*oddR+evenL*evenR)$ ，也可不用全部求出子数组个数：知道某一侧的奇数子数组个数、便可以通过减法求得偶数的，反之亦然。



[ #232 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

亦是第二次做了，想也是想到了「一个入队栈、一个出队栈」的思想，却以为不是线性时间复杂度而不敢下手。这个方法呢：

- `push()`：只往「入队栈」中推入元素
- `pop()`：若「出队栈」为空，则依次向「出队栈」中推入从「入队栈」弹出的元素（达到出队栈中元素排列顺序与原入队栈中相反），最后弹出「出队栈」栈顶元素
- `peek()`：逻辑与 `pop()` 相同，不同的是这里不弹出只读取。
- `empty()`：只有当「入队栈」和「出队栈」同时为空时，才为真，否则假。

这个方法有点「懒汉式」的设计思想，即：只有你需要弹出或者读取值时，才真正把值放在栈顶。这属于是设计层面了，当然现实情况是不会让你造轮子的，只会在已有的数据结构基础上设计高级的数据结构。



[ #1805 字符串中不同整数的数目](https://leetcode.cn/problems/number-of-different-integers-in-a-string/)

今天的每日一题，「`Stream` + 字符串分割 + `BigInteger`」轻松解决。但要是老老实实遍历字符串、双指针，就有些麻烦了，我在处理边界情况上花费了不少时间。现在我使用 `Stream` 流 API 是越来越娴熟了，不得不说真的是很好很强大。



[ #583 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

[ #1143 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

这 2 题其实是同一类题，下题（LCS）是上题的母题，上题我花了 1 个小时也没解出来、最后乖乖看题解。做了这么多 DP 题，发现解题关键就在于「状态的定义」，而这又恰恰是最难的（或许做题多了，就有经验了）。我一开始定义的是一维数组、然后又是定义额外数组存储索引、又是查找字符位置，总之就是很复杂、也很不靠谱。

这题是需要定义二维数组的：`dp[i][j]` 表示以字符串1的第 `i` 个字符结尾的子字符串 与 字符串2的第 `j` 个字符结尾的子字符串 的公共子序列最大长度。

则有 $ dp[i][j]=\begin{cases}
dp[i-1][j-1]+1,\quad s1[i]==s2[j]\\
max(dp[i-1][j],dp[i][j-1]),\quad s1[i]!=s2[j]
\end{cases} $



[ #338 比特位计数](https://leetcode.cn/problems/counting-bits/)

Java 有库函数 `Integer.bitcount()` 可以直接调用来求取一个数的二进制表示中 1 的个数，这个我又忘了。前些日子刚做过类似的题目：[ #191 位1的个数](https://leetcode.cn/problems/number-of-1-bits/)，通过 `n=n&(n-1)` 可以将最低位的 1 反转为 0，这样的话是 $n log n$ 时间。

看了题解才知道竟然有 3 种 dp 方法可以实现线性时间：最高有效位、最低有效位、最低设置位。



2022-12-7

[ #1572 矩阵对角线元素的和](https://leetcode.cn/problems/matrix-diagonal-sum/)

这题我是用了双指针了（一个「左上角 → 右下角」，另一个「左下角 → 右上角」），看了题解才知道原来用单指针就好了（一个「左上角 → 右下角」，另一个「右上角 → 左下角」）。

其实一共有 2 种遍历的方式，效果都是一样的：

- 遍历行：`sum += mat[i][i] + mat[i][n - 1 - i];`
- 遍历列：`sum += mat[i][i] + mat[n - 1 - i][i];`

最后都需要判断矩阵长度的奇偶性来决定要不要减去重叠元素：`return sum - mat[mid][mid] * (n & 1);`



[ #1775 通过最少操作次数使数组的和相等](https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/)

一开始尝试用 dp 做的，但感觉复杂度有点高。花了90分钟看题解，才整明白。

思路大体上是这样的：设数组1、2的元素分别和为 `sum1` 、`sum2`，则：

-  `sum1 == sum2`时，答案为0

-  `sum1 >  sum2`时，设目标数组元素和为 `t` ，则为使 `abs(t - sum1) + abs(t - sum2)` 最小，必有`sum1 >= t >= sum2` ，转换为题意即为：

  - 数组一元素部分值调大（变化值为 `6 - [1, 6]` ，即 `[0, 5]`）
  - 数组一元素部分值调小（变化值为 `[1, 6] - 1` ，即 `[0, 5]`）

  于是我们就有了：计数两数组中元素对缩小差值的贡献值 `[0, 5]` 计数，再贪心的从贡献最大值（5）开始逆序遍历，直到总贡献值 $\ge$ 差值，所用的元素个数即为答案。

- 将两数组对调，即与情况 2 逻辑相同。

这道题用到了「贪心+哈希表+计数+贡献思想」，还是有点难度的、对于我来说。



[ #801 使序列递增的最小交换次数](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/)

又是接触到的全新的状态定义方法：`f[n][2]` 

- `f[i][0]` 表示以索引 `i` 结尾的俩子数组、不交换 `i` 处元素的使序列递增的最小交换次数
- `f[i][1]` 表示以索引 `i` 结尾的俩子数组、    交换 `i` 处元素的使序列递增的最小交换次数

则根据俩数组前后俩元素的数组内和数组间（交叉）关系，推导出状态转移方程：
$$
f[i][0]=\begin{cases}
min(f[i - 1][0], f[i - 1][1]),\quad condition1\:\&\&\:condition2\\
f[i - 1][0],\quad condition1\:\&\&\:!condition2\\
f[i - 1][1],\quad !condition1
\end{cases}\\

f[i][1]=\begin{cases}
min(f[i - 1][0], f[i - 1][1]) + 1,\quad condition1\:\&\&\:condition2\\
f[i - 1][1] + 1,\quad condition1\:\&\&\:!condition2\\
f[i - 1][0] + 1,\quad !condition1
\end{cases}\\

a1 = nums1[i - 1],\quad a2 = nums1[i]\\
b1 = nums2[i - 1],\quad b2 = nums2[i]\\
condition1=a1 < a2 \:\&\&\: b1 < b2\\
condition2=b1 < a2 \:\&\&\: a1 < b2\\
$$


[ #871 最低加油次数](https://leetcode.cn/problems/minimum-number-of-refueling-stops/)

这题有两种方法：

- 最优解（$nlogn$）：「贪心 + 优先队列（大顶堆）」，我们把加油站当成是可以随身携带的油桶、经过加油站时就把油桶带上车（加入大顶堆）、停靠加油站加油当成是使用油桶加油，只有当积攒的油量不足以到达下一个加油站或者终点时、循环取出最大的油桶（所经过加油站的最大油量）加油直至油量足够或者大顶堆为空时（此时将不能达到终点，提前返回答案 -1）。

- DP法（$n^2$)：

  - 状态定义： `f[n+1][n+1]` ，`f[i][j]` 表示经过 `i` 个加油站 停靠 `j` 次能够行驶的最大距离

  - 状态转移方程：

  - ```java
    f[i][j] = Math.max(
        f[i - 1][j - 1] >= station[0] ? f[i - 1][j - 1] + station[1] : 0,
        f[i - 1][j] >= station[0] ? f[i - 1][j] : 0
    );
    ```

  - 最终答案：经过 `n` 个加油站「能够行驶的最大距离 $\ge$ 终点距离」的最小停靠次数。

总结：DP法的状态定义不容易想到，贪心的解法也是不太容易想到，总之这题很不容易、哈哈。



2022-12-8

[#1812 判断国际象棋棋盘中一个格子的颜色](https://leetcode.cn/problems/determine-color-of-a-chessboard-square/)

简单分析格子坐标奇偶性，即可判断黑白。



[ #1768 交替合并字符串](https://leetcode.cn/problems/merge-strings-alternately/)

单指针遍历即可



[ #389 找不同](https://leetcode.cn/problems/find-the-difference/)

做法很多：

- 位异或运算
- 哈希计数
- 排序后遍历，找到第一个不同的字符

其中位异或运算也可以用 `Stream` 流的归约操作替代，即：`(char) (s + t).chars().reduce(0, (a, b) -> a ^ b)`，「归约」就是利用流中元素两两应用函数 `BinaryOperator` 、其结果再与另一个元素应用函数、如此循环直至所有元素归约为一个元素（相同类型），Java 中的 `reduce` 方法还可以有一个起始点（`identity`）。

`chars()` 方法是 Java9 的内容，输出的是 `IntStream` 。



[ #101 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

这题也是第二次做了，却是花了40分钟用了一个奇葩方法低分通过。

其实这道题的关键，我觉得还是要搞懂「对称的方法」：

- 左子节点的左子节点 对称于 右子节点的右子节点，即 `left.left | right.right`
- 左子节点的右子节点 对称于 右子节点的左子节点，即 `left.right | right.left`



其次，是俩节点的判断：

- 都为空，即 `left == null && right == null` ，则为真、继续递归。
- 一空一不空，即 `left == null ^ right == null` ，则为假、提前返回结果。
- 都非空，即 `left != null && right != null` ，则继续判断值是否相等
  - 为假、提前返回结果。
  - 为真、继续递归。



[ #2160 拆分数位后四位数字的最小和](https://leetcode.cn/problems/minimum-sum-of-four-digit-number-after-splitting-digits/)

一开始还在思考「暴力枚举」，但在思考的过程中、我发现「拆成一位数和三位数」和「拆成两个二位数」都是需要高位尽可能的小、而两个数的同位值调换位置对结果没有影响。

于是就有了「贪心 + 排序」的方法，然后我在编码的过程中又发现「拆成一位数和三位数」的最小和总是比「拆成两个二位数」来的大（或者相等）。

数学运算式已经提供了证明，再实际想想：你把一个数放这第三位、相当于乘上100，而你把它放这第二位则是乘上10，何乐而不为呢、你说是不？



2022-12-10

[ #1290 二进制链表转整数](https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/)

可以有两种方法：

- 无脑法：先拼成字符串，再解析：`Integer.parseInt(s, 2)`
- 高效法：位的运算（移位和或）
  - 初始化答案为 `0` （一开始我是初始化为根节点值，原来 `0` 就可以了，因为 `0 << 1 === 0` ）
  - 遍历链表节点值，将答案左移一位、再或上节点值
  - 循环结束，输出答案



[ #404 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

- 递归写法（DFS）写是写出来了，但一看别人的代码、还是比我精简，看来要想代码精简、还得递归复用原函数。
- 还有一种方法是迭代（BFS），我用了 2 个队列来实现的、一看别人的代码、又傻眼了、原来还是可以用 1 个队列实现的。



[ #700 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

- 递归方法和高分解是一样的，注意这里是个尾递归（好像尾递归是不占用递归栈空间的）
- 迭代法倒是竟然没想出来，原理和递归是一样的，只需要更新根节点的引用地址即可



[ #701 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

一开始我给做复杂了，其实这道题的关键是要搞清楚「有很多种可行的插入实现，但有一种是最简单的：只需要将一个节点原来空的左或右子节点指向插入值节点」。

同样两种方法：

- 递归：为什么「根节点为空，返回插入值节点」就一定正确呢？我们可以用反证法证之：假设插入值节点需要 “拼接” 在 2 个节点（`l`、`r`）中间，则势必有 `l.val < target < r.val` ，其实此时可以有两种选择（既可以 “拼接” 在 2 个节点中间，也可以插入 `l` 右侧），插入 `l` 右侧时若已存在右子节点，则这种情况下，是有 `l.right.val < target < r.val` 的大小关系的，这与前置条件不符。
  - 根节点为空，返回插入值节点
  - 根节点值 < 插入值，将右子节点指针 指向 递归调用右子节点的返回值
  - 根节点值 > 插入值，将左子节点指针 指向 递归调用左子节点的返回值

- 迭代：思路同递归



[ #1691 堆叠长方体的最大高度](https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/)

这题的母题其实是 LIS （最长递增子序列），只不过这题不是求的递增子序列的最大长度、而是递增子序列的「最大堆叠高度」。

关键点：

- 长方体1（`w1 <= l1 <= h1`） 能堆叠在 长方体2（`w2 <= l2 <= h2`） 上的充分必要条件：`w1 <= w2 && l1 <= l2 && h1 <= h2` ，详细证明过程可以看灵神的题解。
- 长方体1（`w1 <= l1 <= h1`） 能堆叠在 长方体2（`w2 <= l2 <= h2`）时，两者的堆叠最大高度为 `w为宽、l为长、h为高` 时，此时的高度为 `h1+h2 `。
- 每个长方体按照各边长度排序、所有长方体按照「最短边、次短边、最长边」依次排序，这样做动态规划枚举时子问题的求解只需要考虑前面已求出的子问题。



[ #1230 抛掷硬币](https://leetcode.cn/problems/toss-strange-coins/)

单串带维度 DP 题

关键在于：

- 首先要明确状态数组定义时的大小和相对应的含义，不要整糊涂了
- 其次是要明白「 0 枚硬币正面」的情况，是要作特殊考虑的，不能套用状态转移方程（要套用也可以，需要将 `f[0][1]` 初始化为特定的值：`1.0` ）

- 最后就是状态转移方程了，我一开始就写出来了：`f[i][j] = f[i - 1][j - 1] * prob[i - 1] + f[i - 1][j] * (1 - prob[i - 1])`



今日总结：虽然 `Hard` 题该不会的还是不会、看题解也要理解半天，且能解答的题目也不够精简优雅，但好在是能够独立解题的、每天都有新的知识技巧进入。

祝明天周赛不要紧张、发挥出应有的水平、争取上大分拿AK！！💪💪💪



2022-12-12

[ #1781 所有子字符串美丽值之和](https://leetcode.cn/problems/sum-of-beauty-of-all-substrings/)

这题也是没想到好像最优解就是「暴力+枚举」，不过我一开始给搞复杂了：先求了前缀和。



[ #122 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

- 最优解：贪心，只要某天股价比昨天上涨（`prices[i] - prices[i - 1] > 0`），我们就买入昨天的股票、在今天卖出。
  - 我虽然一开始也想到了贪心解法，但逻辑有些复杂了。事实上并不需要计算出股价的最低点和最低点后的最高点，「过一天算一天」就好了。
- DP：这题用到了二维状态数组，这里的状态表示是否持股。
  - `f[i][k]` 表示前 `i - 1` 天、持股状态为 `k` 时的最大现金（可能为负），注意定义的是现金。



[ #714 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

- 最优解：贪心，这题的贪心解法看了题解都觉得有些费解和奇妙：手续费既可以在买入股票时计入，也可在卖出股票时计入，我们这里选择买入股票时计入，这样方便判断某一天的股票价格是否达到获利条件（`prices[i] > buy`），我们分 3 种情况讨论
  - `prices[i] is in (-inf, buy - fee)` ，此时当前股价较小，我们更新最低买入价格 `buy = prices[i] + fee`
  - `prices[i] is in [buy - fee, buy]`，此时当前股价既没有过低、也没有高到可以卖出股票，我们无操作进入下次循环。
  - `prices[i] is in (buy, +inf)`， 此时当前股价较高，可以卖出股票获利，我们更新最低买入价格 `buy = prices[i]`（注意这里没有加上手续费的原因是：我们可能在这一天卖出股票后又买入股票，相当于不计手续费），更新最大利润值。
- DP：解法和 [ #122 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/) 类似，只不过多了一个手续费。



[#712 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/)

- DP1：直接DP（母题为 LCS（最长公共子序列））
- DP2：曲线DP，先求最大公共子序列的ASCII和，再用减法求出答案。



[ #718 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

- DP：我们定义 `f[i][j]` 表示以数组1的第 `i` 个数、数组2的第 `j` 个数为结尾的公共子数组最大长度，则只有当两索引处元素值相等时、才计算递推状态值：`f[i][j] = f[i - 1][j - 1] + 1`
- 滑动窗口和二分以后有时间再看看吧，我老是没有定力看长文字。



[ #10 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

这题之前做过？不过当时应该是放弃了的、留了个TODO。

这次再做、也是花了挺长时间看题解的。

DP的关键点：

- 2个字符串要从右往左匹配
- '*' 的匹配需要考虑 3 种情况（匹配0、1、$\ge$2次）



今日总结：由于昨天作息不规律（晚八点睡，凌晨两点起），今天好像学习时间很多，做了9道新题，应该是刷新了个人日做题数记录了。祝自己好梦，晚安❤



2022-12-13

[ #72 编辑距离](https://leetcode.cn/problems/edit-distance/)

状态定义为 `f[i][j]` 表示字符串1的前 `i` 个字符 转换成 字符串2的前 `j` 个字符 所需的最小操作数

关键点：

- `f[i][j]` 似乎永远不小于 `f[<=i][<=j]` 
- 状态递推时，我们以两字符是否相等为考虑条件、最后一步的操作类型（增、删、改）为实际意义。
- 操作的先后顺序不影响结果

吐槽：还是有点似懂非懂的



[ #97 交错字符串](https://leetcode.cn/problems/interleaving-string/)

关键在于理解 `|n - m| <= 1` 怎么满足。

推导过程一定满足 s1 和 s2 是交错的，因为 `n=m` 、`|n - m| = 1` 这两种情况下在末尾添加一个字符要么与原末尾字符同属（则保持原交错差值）、要么与原末尾字符不同属（仍为交叉）。



[#120 三角形最小路径和](https://leetcode.cn/problems/triangle/)

这道题 DP 有 2 种方法：

- 自顶向下（差），需要考虑边界情况，最后还要求最小值
- 自底向上（优），不需要考虑边界情况，最后直接返回 `f[0][0]`

