|   日期    | 题目                                                         | 难度 | 解题情况  | 耗时/min | WA次数 | 算法与数据结构                                               | 重做次数 | 重做？ |
| :-------: | :----------------------------------------------------------- | :--: | :-------: | -------: | :----: | ------------------------------------------------------------ | :------: | :----: |
| 2022/12/5 | [83. Remove Duplicates from Sorted List  ](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/?envType=study-plan&id=shu-ju-jie-gou-ru-men&plan=data-structures&plan_progress=14lldz3) | Easy |   通过    |        8 |        | Linked List                                                  |          |        |
|           | [589. N-ary Tree Preorder Traversal  ](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/description/?envType=study-plan&id=programming-skills-beginner&plan=programming-skills&plan_progress=1jujsjv) | Easy |   通过    |        8 |        | Stack Tree Depth-First Search                                |          |        |
|           | [496. Next Greater Element I  ](https://leetcode.cn/problems/next-greater-element-i/description/?envType=study-plan&id=programming-skills-beginner&plan=programming-skills&plan_progress=1jujsjv) | Easy |   通过    |       11 |        | Stack Array Hash Table Monotonic Stack                       |          |        |
|           | [1232. Check If It Is a Straight Line  ](https://leetcode.cn/problems/check-if-it-is-a-straight-line/description/?envType=study-plan&id=programming-skills-beginner&plan=programming-skills&plan_progress=1jujsjv) | Easy |   通过    |        9 |   1    | Geometry Array Math                                          |          |        |
|           | [1687. Delivering Boxes from Storage to Ports  ](https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/description/) | Hard | CV-未通过 |      135 |   5    | Segment Tree Queue Array Dynamic Programming Monotonic Queue Heap (Priority Queue) |          |   Y    |

[ #83 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

这题总的来说有三种解法：

1. 递归（相邻节点值相同，就更新指针）
2. 迭代（相邻节点值相同，就更新指针）
3. 迭代（向后寻找第一个与当前节点值不同的节点，并更新指针）

总的来说，这 3 种解法从上到下所需思考量依次升高、时空复杂度依次降低。而我一开始AC的代码是第三种，要是竞赛的话还是用第一种吧。



[ #589 N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)

1. 递归
2. 显示栈

递归当然是最好写的，模仿二叉树的写法就可以了；显示栈法则是模拟递归的过程，写起来稍显复杂，需要倒序遍历子节点入栈。

p.s：刚刚试了一下用队列的方法，果然还是不行呀！！递归就是栈的「后进先出」特点，是不能用队列的「先进先出」代替的！！

p.p.s：不知道能不能用「Morris法」呀，对于目前的学习目标没有打算深入研究，毕竟空间优化是次之的。



[ #496 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

1. ①哈希表存储 `num2` 的值到索引的映射，②双层循环遍历求出每个 `num1` 中的元素的下一个更大元素。虽然时间上较纯双层遍历更优，仍有优化余地。
2. 看到「单调栈」的标签后，尝试实现了：①哈希表存储 `num2` 的「值 → 索引」的映射，②额外开辟数组，存储 `num2` 中每个元素的下一个更大元素（利用单调栈实现线性时间）③遍历求出每个 `num1` 中的元素的下一个更大元素。

​	   这里可以看到「元素值 → 索引 →下一个更大元素」的求解过程中，「索引」这一步是多余的，我之所以建哈希表可能是受第一个方法实现的思维惯性影响。

3. ①哈希表存储 `num2` 的「值 → 下一个更大元素的映射」的映射，②遍历求出每个 `num1` 中的元素的下一个更大元素。

看来自己对单调队列/栈的运用和练习还不够，以后有空可以加强一下。



[ #1232 缀点成线](https://leetcode.cn/problems/check-if-it-is-a-straight-line/)

1. 斜率法（比较繁琐且低效，需要考虑除数为 0 的特殊情况、除法需要转浮点数处理，除法本身较乘法就是低效的）
2. 斜率法转乘法

也是受教了，以后除法不要忘了考虑除数为 0 的情况，另外能用乘法就不要用除法、一些题目如果对元素值进行乘法预处理不影响结果的话就果断用上。



[ #132 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

这题一开始我应该想到了 DP 法：定义 `dp[i]` 表示以索引 `i` 结尾的子字符串的最小分割数， `dp[i]` 的求解需要 2 层循环，每个子字符串的回文判定又需要一层循环，总体时间复杂度达到 $O(n^3)$ ，于是就放弃了 DP 的思路，开启了乱七八糟写代码模式、吭哧吭哧 2 个小时调试来调试去的最后还是选择放弃乖乖看题解。

关键点在于：先预处理出每个子字符串的回文情况 `isPalindrome[l][r]` 。



[ #1687 从仓库到码头运输箱子](https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/)

听说这是一道力扣题库 Rank20 的神题，自己也是光看题解、cv代码就花费 2 个小时。

牵涉到的知识点有：前缀和、dp、单调队列。

另外这里的 dp 求解时的枚举对象我也是没想到的，她枚举的是「上一次运送的最后一个箱子」，而我呢、想的是怎么保存 `dp[i]` 的最后一次运送状态（箱子数和箱子总重）、看元素 `i` 能不能加入 `dp[i-1]`的最后一次运送中，这个思路是行不通的、按照经验枚举 `i` 前面的索引 `j` 即可。