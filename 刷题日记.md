2022-12-5

[ #83 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

这题总的来说有三种解法：

1. 递归（相邻节点值相同，就更新指针）
2. 迭代（相邻节点值相同，就更新指针）
3. 迭代（向后寻找第一个与当前节点值不同的节点，并更新指针）

总的来说，这 3 种解法从上到下所需思考量依次升高、时空复杂度依次降低。而我一开始AC的代码是第三种，要是竞赛的话还是用第一种吧。



[ #589 N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)

1. 递归
2. 显示栈

递归当然是最好写的，模仿二叉树的写法就可以了；显示栈法则是模拟递归的过程，写起来稍显复杂，需要倒序遍历子节点入栈。

p.s：刚刚试了一下用队列的方法，果然还是不行呀！！递归就是栈的「后进先出」特点，是不能用队列的「先进先出」代替的！！

p.p.s：不知道能不能用「Morris法」呀，对于目前的学习目标没有打算深入研究，毕竟空间优化是次之的。



[ #496 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

1. ①哈希表存储 `num2` 的值到索引的映射，②双层循环遍历求出每个 `num1` 中的元素的下一个更大元素。虽然时间上较纯双层遍历更优，仍有优化余地。
2. 看到「单调栈」的标签后，尝试实现了：①哈希表存储 `num2` 的「值 → 索引」的映射，②额外开辟数组，存储 `num2` 中每个元素的下一个更大元素（利用单调栈实现线性时间）③遍历求出每个 `num1` 中的元素的下一个更大元素。

​	   这里可以看到「元素值 → 索引 →下一个更大元素」的求解过程中，「索引」这一步是多余的，我之所以建哈希表可能是受第一个方法实现的思维惯性影响。

3. ①哈希表存储 `num2` 的「值 → 下一个更大元素的映射」的映射，②遍历求出每个 `num1` 中的元素的下一个更大元素。

看来自己对单调队列/栈的运用和练习还不够，以后有空可以加强一下。



[ #1232 缀点成线](https://leetcode.cn/problems/check-if-it-is-a-straight-line/)

1. 斜率法（比较繁琐且低效，需要考虑除数为 0 的特殊情况、除法需要转浮点数处理，除法本身较乘法就是低效的）
2. 斜率法转乘法

也是受教了，以后除法不要忘了考虑除数为 0 的情况，另外能用乘法就不要用除法、一些题目如果对元素值进行乘法预处理不影响结果的话就果断用上。



[ #132 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

这题一开始我应该想到了 DP 法：定义 `dp[i]` 表示以索引 `i` 结尾的子字符串的最小分割数， `dp[i]` 的求解需要 2 层循环，每个子字符串的回文判定又需要一层循环，总体时间复杂度达到 $O(n^3)$ ，于是就放弃了 DP 的思路，开启了乱七八糟写代码模式、吭哧吭哧 2 个小时调试来调试去的最后还是选择放弃乖乖看题解。

关键点在于：先预处理出每个子字符串的回文情况 `isPalindrome[l][r]` 。



[ #1687 从仓库到码头运输箱子](https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/)

听说这是一道力扣题库 Rank20 的神题，自己也是光看题解、cv代码就花费 2 个小时。

牵涉到的知识点有：前缀和、dp、单调队列。

另外这里的 dp 求解时的枚举对象我也是没想到的，她枚举的是「上一次运送的最后一个箱子」，而我呢、想的是怎么保存 `dp[i]` 的最后一次运送状态（箱子数和箱子总重）、看元素 `i` 能不能加入 `dp[i-1]`的最后一次运送中，这个思路是行不通的、按照经验枚举 `i` 前面的索引 `j` 即可。



2022-12-6

[ #1588 所有奇数长度子数组的和](https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/)

第二次做了，AC很容易（由于数据量很小，n^3^ 或者 n^2^ 解法就可以通过），时隔一个月不到、还是记起了可以通过「贡献法」达到线性时间复杂度，即遍历数组、求解每个元素在奇数长度子数组中出现的次数。

但我还是花了40多分钟才AC，究其原因是没有明确好当前元素 `arr[i]` 、左侧元素 `arr[0...i-1]` 、右侧元素 `arr[i+1...n-1]` 元素是否一定要选、选几个的限制条件。我总是事后才明白很多东西，因为是「贡献法」，所以当前元素 `arr[i]` 必选，则左侧元素与右侧元素的选择方法数之和必为偶数（奇数+奇数 or 偶数+偶数），贡献次数为 = 左侧元素以 `arr[i-1]` 结尾的奇数子数组个数 * 右侧元素以 `arr[i+1]` 开头的奇数子数组个数 + 左侧元素以 `arr[i-1]` 结尾的偶数子数组个数（包括空子数组） * 右侧元素以 `arr[i+1]` 开头的偶数子数组个数（包括空子数组），记为：$ans=\sum_{i=0}^{n-1} arr[i]*(oddL*oddR+evenL*evenR)$ ，也可不用全部求出子数组个数：知道某一侧的奇数子数组个数、便可以通过减法求得偶数的，反之亦然。



[ #232 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

亦是第二次做了，想也是想到了「一个入队栈、一个出队栈」的思想，却以为不是线性时间复杂度而不敢下手。这个方法呢：

- `push()`：只往「入队栈」中推入元素
- `pop()`：若「出队栈」为空，则依次向「出队栈」中推入从「入队栈」弹出的元素（达到出队栈中元素排列顺序与原入队栈中相反），最后弹出「出队栈」栈顶元素
- `peek()`：逻辑与 `pop()` 相同，不同的是这里不弹出只读取。
- `empty()`：只有当「入队栈」和「出队栈」同时为空时，才为真，否则假。

这个方法有点「懒汉式」的设计思想，即：只有你需要弹出或者读取值时，才真正把值放在栈顶。这属于是设计层面了，当然现实情况是不会让你造轮子的，只会在已有的数据结构基础上设计高级的数据结构。



[ #1805 字符串中不同整数的数目](https://leetcode.cn/problems/number-of-different-integers-in-a-string/)

今天的每日一题，「`Stream` + 字符串分割 + `BigInteger`」轻松解决。但要是老老实实遍历字符串、双指针，就有些麻烦了，我在处理边界情况上花费了不少时间。现在我使用 `Stream` 流 API 是越来越娴熟了，不得不说真的是很好很强大。



[ #583 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

[ #1143 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

这 2 题其实是同一类题，下题（LCS）是上题的母题，上题我花了 1 个小时也没解出来、最后乖乖看题解。做了这么多 DP 题，发现解题关键就在于「状态的定义」，而这又恰恰是最难的（或许做题多了，就有经验了）。我一开始定义的是一维数组、然后又是定义额外数组存储索引、又是查找字符位置，总之就是很复杂、也很不靠谱。

这题是需要定义二维数组的：`dp[i][j]` 表示以字符串1的第 `i` 个字符结尾的子字符串 与 字符串2的第 `j` 个字符结尾的子字符串 的公共子序列最大长度。

则有 $ dp[i][j]=\begin{cases}
dp[i-1][j-1]+1,\quad s1[i]==s2[j]\\
max(dp[i-1][j],dp[i][j-1]),\quad s1[i]!=s2[j]
\end{cases} $



[ #338 比特位计数](https://leetcode.cn/problems/counting-bits/)

Java 有库函数 `Integer.bitcount()` 可以直接调用来求取一个数的二进制表示中 1 的个数，这个我又忘了。前些日子刚做过类似的题目：[ #191 位1的个数](https://leetcode.cn/problems/number-of-1-bits/)，通过 `n=n&(n-1)` 可以将最低位的 1 反转为 0，这样的话是 $n log n$ 时间。

看了题解才知道竟然有 3 种 dp 方法可以实现线性时间：最高有效位、最低有效位、最低设置位。



2022-12-7

[ #1572 矩阵对角线元素的和](https://leetcode.cn/problems/matrix-diagonal-sum/)

这题我是用了双指针了（一个「左上角 → 右下角」，另一个「左下角 → 右上角」），看了题解才知道原来用单指针就好了（一个「左上角 → 右下角」，另一个「右上角 → 左下角」）。

其实一共有 2 种遍历的方式，效果都是一样的：

- 遍历行：`sum += mat[i][i] + mat[i][n - 1 - i];`
- 遍历列：`sum += mat[i][i] + mat[n - 1 - i][i];`

最后都需要判断矩阵长度的奇偶性来决定要不要减去重叠元素：`return sum - mat[mid][mid] * (n & 1);`



[ #1775 通过最少操作次数使数组的和相等](https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/)

一开始尝试用 dp 做的，但感觉复杂度有点高。花了90分钟看题解，才整明白。

思路大体上是这样的：设数组1、2的元素分别和为 `sum1` 、`sum2`，则：

-  `sum1 == sum2`时，答案为0

-  `sum1 >  sum2`时，设目标数组元素和为 `t` ，则为使 `abs(t - sum1) + abs(t - sum2)` 最小，必有`sum1 >= t >= sum2` ，转换为题意即为：

  - 数组一元素部分值调大（变化值为 `6 - [1, 6]` ，即 `[0, 5]`）
  - 数组一元素部分值调小（变化值为 `[1, 6] - 1` ，即 `[0, 5]`）

  于是我们就有了：计数两数组中元素对缩小差值的贡献值 `[0, 5]` 计数，再贪心的从贡献最大值（5）开始逆序遍历，直到总贡献值 $\ge$ 差值，所用的元素个数即为答案。

- 将两数组对调，即与情况 2 逻辑相同。

这道题用到了「贪心+哈希表+计数+贡献思想」，还是有点难度的、对于我来说。



[ #801 使序列递增的最小交换次数](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/)

又是接触到的全新的状态定义方法：`f[n][2]` 

- `f[i][0]` 表示以索引 `i` 结尾的俩子数组、不交换 `i` 处元素的使序列递增的最小交换次数
- `f[i][1]` 表示以索引 `i` 结尾的俩子数组、    交换 `i` 处元素的使序列递增的最小交换次数

则根据俩数组前后俩元素的数组内和数组间（交叉）关系，推导出状态转移方程：
$$
f[i][0]=\begin{cases}
min(f[i - 1][0], f[i - 1][1]),\quad condition1\:\&\&\:condition2\\
f[i - 1][0],\quad condition1\:\&\&\:!condition2\\
f[i - 1][1],\quad !condition1
\end{cases}\\

f[i][1]=\begin{cases}
min(f[i - 1][0], f[i - 1][1]) + 1,\quad condition1\:\&\&\:condition2\\
f[i - 1][1] + 1,\quad condition1\:\&\&\:!condition2\\
f[i - 1][0] + 1,\quad !condition1
\end{cases}\\

a1 = nums1[i - 1],\quad a2 = nums1[i]\\
b1 = nums2[i - 1],\quad b2 = nums2[i]\\
condition1=a1 < a2 \:\&\&\: b1 < b2\\
condition2=b1 < a2 \:\&\&\: a1 < b2\\
$$


[ #871 最低加油次数](https://leetcode.cn/problems/minimum-number-of-refueling-stops/)

这题有两种方法：

- 最优解（$nlogn$）：「贪心 + 优先队列（大顶堆）」，我们把加油站当成是可以随身携带的油桶、经过加油站时就把油桶带上车（加入大顶堆）、停靠加油站加油当成是使用油桶加油，只有当积攒的油量不足以到达下一个加油站或者终点时、循环取出最大的油桶（所经过加油站的最大油量）加油直至油量足够或者大顶堆为空时（此时将不能达到终点，提前返回答案 -1）。

- DP法（$n^2$)：

  - 状态定义： `f[n+1][n+1]` ，`f[i][j]` 表示经过 `i` 个加油站 停靠 `j` 次能够行驶的最大距离

  - 状态转移方程：

  - ```java
    f[i][j] = Math.max(
        f[i - 1][j - 1] >= station[0] ? f[i - 1][j - 1] + station[1] : 0,
        f[i - 1][j] >= station[0] ? f[i - 1][j] : 0
    );
    ```

  - 最终答案：经过 `n` 个加油站「能够行驶的最大距离 $\ge$ 终点距离」的最小停靠次数。

总结：DP法的状态定义不容易想到，贪心的解法也是不太容易想到，总之这题很不容易、哈哈。



2022-12-8

